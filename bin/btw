#!/bin/sh

# pipe commands output between your docker container and docker host
#
#      # in docker container run
#      cmd1 | cmd2 ... | con -e 'cmd' | cmd3
#
#      Where 'cmd' is executed in your docker host

# IP addr of the docker interface
IF_IP=

PORT=

# command btw pipes
E_CMD=

# brigde index
IF_INDEX=1

# in server mode or not?
SERVER_MODE=

usage() {
   printf 'Usage: %s [-h] [-s] [-p PORT] [-e CMD] [-i N]\n' "$0" >&2
   printf '\t-h: Display this help message and exit.\n' >&2
   printf '\t-s: Switch to server mode, listen to clients for commands.\n' >&2
   printf '\t-e: Send command "CMD" to server for execution and pour out its output.\n' >&2
   printf '\t-p: Port to listen(Server)/establish(Client) connection.\n' >&2
   printf '\t-i: Defaults to the first brigde. Establish a connection to the Nth Docker brigde\n' >&2
   printf '\t    to listen for commands(in server mode) or send commands(in client mode). \n' >&2
   exit 1
}

is_digit() {
   if ! expr "$1" : '[0-9]\+$' >/dev/null ; then
      printf "%s: ERROR: argument to \`%s' must be an integer" "$0" "$2" >&2
      exit 1
   fi
}

parse_check_args() {

   while getopts se:i:p:h OPTS ; do
      case "$OPTS" in
         h | \?)
            usage
            ;;
         s)
            SERVER_MODE=1
            ;;
         e)
            E_CMD=$OPTARG
            ;;
         p)
            is_digit "$OPTARG" -p
            PORT=$OPTARG
            ;;
         i)
            is_digit "$OPTARG" -i
            IF_INDEX=$OPTARG
            ;;
      esac

      IF_INDEX=${IF_INDEX:-1}
      PORT=${PORT:-1234}
      if [ -z "$SERVER_MODE" ] && [ -z "$E_CMD" ] ; then
         printf '%s: ERROR: your are not in server mode\n' "$0" >&2
         printf "%s: ERROR: use \`-e' option to send a command\n" "$0" >&2
         usage
      fi
   done
}

get_ip_address() {
   local IN_DOCKER=1 

   ip addr show | grep -qE 'docker[0-9]+' && IN_DOCKER=0
   IF_IP=$(
      ip addr show | awk -v in_docker=$IN_DOCKER -v if_index=$IF_INDEX '
         BEGIN {
            found_ip = 0
            index_c = 0
         }
         function add_index() {
            index_c += 1 
            if ( index_c == if_index )
               found_ip = 1
         }
         /[1-9]+: docker[0-9]+:/ {
            if ( !in_docker )
               add_index()
         }
         /[1-9]+: eth[0-9]@if[0-9]+:/ {
            if ( in_docker )
               add_index()
         }
         /inet [1-9][0-9]+(\.[1-9][0-9]+)+/ {
            if ( found_ip ) {
               sub("\.[0-9]+/[0-9]+$", ".1", $2)
               print $2
               exit(0)
            }
         }
      '
   )

   if [ -z "$IF_IP" ] ; then
      printf "%s: ERROR: failed to get bridge addr with index '%s'\n" "$0" $IF_INDEX >&2
      exit 1
   fi
}

submit_data_to_server() {
   # send CMD
   printf '%s\n' "$E_CMD" | nc "$IF_IP" $PORT

   if [ $? -ne 0 ] ; then
      printf '%s: ERROR: could establish connection to server\n' "$0" >&2
      exit 1
   fi

   nc "$IF_IP" $PORT
}

command_executor_server() {
   local CMD=
   local BUF_FILE=$(mktemp -u /tmp/btw-buf-XXXXXX) FIFO_CMD=$(mktemp -u /tmp/btw-cmd-XXXXXX)

   printf 'Starting the command executor server\n'
   printf 'Listening on %s:%s\n' "$IF_IP" $PORT

   touch $BUF_FILE
   while [ 1 ] ; do
      CMD=$(nc -l "$IF_IP" $PORT)

      printf "Executing '%s'\n" "$CMD"
      tail -f $BUF_FILE | nc -l "$IF_IP" $PORT | sh -c "$CMD" >>$BUF_FILE
   done
}

main() {
   parse_check_args "$@"

   get_ip_address
   if [ -n "$SERVER_MODE" ] ; then
      command_executor_server
   else
      submit_data_to_server
   fi
}

main "$@"
