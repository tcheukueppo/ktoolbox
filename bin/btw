#!/bin/sh

# pipe commands output between your docker container and docker host
#
#      # in docker container run
#      cmd1 | cmd2 ... | con -e 'cmd' | cmd3
#
#      Where 'cmd' is executed in your docker host

# IP addr of the docker interface
IF_IP=

PORT=

# command btw pipes
E_CMD=

# brigde index
IF_INDEX=1

# in server mode or not?
SERVER_MODE=

usage() {
   printf 'Usage: %s [-h] [-s] [-e CMD] [-i N]\n' "$0" >&2
   printf '\t-h: Display this help message and exit.\n' >&2
   printf '\t-s: Switch in server mode, listen to clients for commands.\n' >&2
   printf '\t-e: Send command "CMD" to server for execution and pour out its output.\n' >&2
   printf '\t-i: Defaults to the first brigde. Establish a connection to the Nth Docker brigde\n' >&2
   printf '\t    to listen for commands(in server mode) or send commands(in client mode). \n' >&2
   exit 1
}

parse_check_args() {
   while getopts se:i:h OPTS ; do
      case "$OPTS" in
         h | \?)
            usage
            ;;
         s)
            SERVER_MODE=1
            ;;
         e)
            E_CMD=$OPTARG
            ;;
         d)
            IF_INDEX=$OPTARG
            if ! expr "$IF_INDEX" : '[0-9]\+$' >/dev/null ; then
               printf "%s: ERROR: argument to \`-d' must be an integer" "$0" >&2
               exit 1
            fi
            ;;
      esac

      IF_INDEX=${IF_INDEX:-1}
      if [ -z "$SERVER_MODE" ] && [ -z "$E_CMD" ] ; then
         printf '%s: ERROR: your are not in server mode\n' "$0" >&2
         printf "%s: ERROR: use \`-e' option to send a command\n" "$0" >&2
         usage
      fi
   done
}

get_ip_address() {
   local IN_DOCKER=1 

   ip addr show | grep -qE 'docker[0-9]+' && IN_DOCKER=0
   IF_IP=$(
      ip addr show | awk -v in_docker=$IN_DOCKER -v if_index=$IF_INDEX '
         BEGIN {
            found_ip = 0
            index_c = 0
         }
         function add_index() {
            index_c += 1 
            if ( index_c == if_index )
               found_ip = 1
         }
         /[1-9]+: docker[0-9]+:/ {
            if ( !in_docker )
               add_index()
         }
         /[1-9]+: eth[0-9]@if[0-9]+:/ {
            if ( in_docker )
               add_index()
         }
         /inet [1-9][0-9]+(\.[1-9][0-9]+)+/ {
            if ( found_ip ) {
               sub("/.+$", "", $2)
               print $2
               exit(0)
            }
         }
      '
   )

   if [ -z "$IF_IP" ] ; then
      printf "%s: ERROR: failed to get brigde addr with index '%s'\n" "$0" "$IF_INDEX" >&2
      exit 1
   fi
}

send_command_to_server() {
   printf '%s\n' "$E_CMD" | nc $IF_IP
}

command_executor_server() {
   local CMD= SEND_CMD=
   local FIFO_BUF=$(mktemp -u /tmp/btw-buf-XXXXXX) FIFO_CMD=$(mktemp -u /tmp/btw-cmd-XXXXXX)

   printf 'Starting the command executor server\n'
   printf 'Listening on %s:%s\n' "$IF_IP" "$PORT"

   mkfifo "$FIFO_BUF" "$FIFO_CMD"

   cat "$FIFO_BUF" | nc -l $IF_IP | {
      while read BUF ; do
         if [ -z "$SEND_CMD" ] ; then
            printf "Executing '%s'\n" "$BUF"
            printf '%s\n' "$BUF" >"$FIFO_CMD" &
            SEND_CMD=1
         fi

         printf '%s\n' "$BUF"
      done
   } | sh -c "$(cat "$FIFO_CMD")" 2>&1 >"$FIFO_BUF"

}

main() {
   parse_check_args "$@"
   if [ "$SERVER_MODE" ] ; then
      command_executor_server
   fi
   send_command_to_server
}

main "$@"
