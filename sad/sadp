#!/bin/sh
#
# sadp - ctl for SAD daemon.
# Copyright Â© 2022 Kueppo Tcheukam <kueppo@paranoid.cm>
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Created: 2022-02-03

scriptversion=2022-02-04; # UTC

# echo is not posix compliant and using printf is tedious
as_echo='printf %s\n '

me=`$as_echo "$0" | sed -e 's,.*/,,'`

fn_as_exit () { exit $1; }

# Check if sad audio daemon is installed.
if (
	exit_status=true;
	expected_output="usage: sad [-f sock]"
	{ test -x "`command -v sad`" &&
	  test "X`sad -h 2>&1`" = "X$expected_output"
	} && exit_status=false
	${exit_status}	
)
then
	$as_echo "$me: cannot connect to SAD audio daemon" >&2
	fn_as_exit 1
fi

# sadp communicates with sad through openbsd-netcat
# so check if nc is installed and make sure it's not
# the weird gnu-netcat.
if test -x "`command -v nc`"; then
	case `nc -V 2>&1 | head -n1` in
		*GNU* )
			$as_echo "$me: $me depends on openbsd-netcat."
			fn_as_exit 1 ;;
		* ) : ;;
	esac
else
	$as_echo "$me: $me depends on openbsd-netcat"
	if test "X`uname`" = XLinux; then
		$as_echo "Openbsd-netcat has been ported to Linux"
		$as_echo "Check at https://security.archlinux.org/package/openbsd-netcat."
	fi
	fn_as_exit 1
fi

# Check if the SAD daemon is actually running.
if ! pgrep -x sad >/dev/null 2>&1; then
	{ $as_echo "$me: no running process with name sad"
	  $as_echo "$me client requires a running SAD daemon."
	} >&2
	fn_as_exit 1
fi

# If no path to socket was precised during sad's invokation, then
# sad uses /tmp/sad-sock as the default unix domain socket.
: ${sock="/tmp/sad-sock"}

config_dir="${XDG_HOME_CONFIG:-"$HOME/.config"}"
: ${config="$config_dir/sad"}

mkdir -p "$config"

: ${file_name_playlist="$config/sad.pl"}
: ${metadata_playlist="$config/sadm.pl"}

# if test -f "$rfile"; then repeat=yes; else repeat=no; fi
: ${rfile="$config/repeat"}

# `$cur_song' refers to the id of the currently playing song, doing
# so to provide a more sane way for toggling repeat.
: ${cur_song="$config/id"}

: ${incr_song_id=0}

mkdir -p "$cur_song"
if test -n "$cur_song"; then
	omask=`umask`
	umask 0277 && mkdir -p "$cur_song"
	umask $omask
fi

: ${showhelp=yes}

strip_ids='s/^[[:digit:]]*: \(.*\)/\1/'
digits='^[[:digit:]]\+$'

usage="\
usage: $me [OPTION]

Control Simple Audio Daemon (S.A.D)

Only one of its operation modes can be use at a time, Invoking
sadp with no option(s) open its TUI.

Options:

     -help      display this help and exit
     -version   display version info and exit

  -add    DIR1 DIR2...  find under these directories for media files of type mp3
                        wav, ogg, and flac, then add them to the sad playlist
  -search MENU_PROG     search for songs, other possible menus are dmenu, and fzf
                        the default menu is dmenu
	-sock   SOCK_PATH     precise the unix domain socket to connect to SAD
  -notify PROGNAME      send desktop notifications with PROGNAME about the new
                        playing song, the argument PROGNAME is mandatory
  -info                 display information on the standard output about the currently
                        playing song
  -clear                clear playlist
  -kill                 kill the audio daemon
  -pause                toggle pause
  -repeat               toggle repeat
  -random               randomly switch between songs, don't follow any order
  -next                 play next song
  -previous             play previous song

Report bugs and patches to <kueppo@paranoid.cm>."

help="Try \`$me --help' for more information."

version="\
sadp ($scriptversion)

Copyright Free Software Foundation, Inc.

This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTIBILITY or FITNESS FOR A PARTICULAR PURPOSE."

###---------------
###  Functions
###---------------

# set_socket PATH_TO_UNIX_DOMAIN_SOCKET
# -------------------------------------
# Set socket file instead of the default unix domain socket at /tmp/sad-sock.
set_socket () { test -S "$1" && sock="$1" || $as_echo "$me: $1 is not a socket"; }

# snc
# ---
# A simplified nc, it exits after recieving EOF and filters useless data.
snc () { nc -N -U "$sock" | grep -v '^OK$' | grep -v '^ERR$'; }

# no_metadata MEDIA_FILE
# ----------------------
# no_metadata simply fill in the basename of MEDIA_FILE to the $metadata_playlist
# since ffmpeg is not present.
no_metadata () { printf '%d:%s' "$2" `basename "$1"`; }

# with_metadata MEDIA_FILE_ABS_PATH
# ---------------------------------
# with_metadata extracts metadata from the media file passed as parameter
# these informations a filled into the $metadata_playlist
extract_metadata ()
{
	# rewrite IDs if remove_song_from_playlist was called
	if test -s "$metadata_playlist" && test `cat "$metadata_playlist" | head -n1 | cut -d ';' -f1` -ne 0
	then
		new_metadata_file="$(mktemp -u /tmp/XXXX)"
		cat "$metadata_playlist" | awk -F[';'] '{ printf("%d;%s\n", (NR - 1), $2); }' > "$new_metadata_file"
		mv "$new_metadata_file" "$metadata_playlist"
		rm -f "$new_metadata_file"
	fi
	while read media_file; do
		# Without any knowlegde about possible options `ffprobe' could have to easily
		# extract usable metadata on media files, we got this
		tags=`ffprobe -hide_banner "$media_file" 2>&1 |
		awk '
			BEGIN { FS = "[[:space:]]*:[[:space:]]*" }
			/^Input #[[:digit:]],/ {
				match($0, "'\''.+'\'':")
				meta["filename"] = substr($0, RSTART + 1, RLENGTH - 3)
				sub(/^\.?\.?(\/[^\/]+)*\//, "", meta["filename"])
				next
			}
			$1 ~ /^[[:space:]]+track$/ {
				if ($2 ~ /[[:digit:]]\/[[:digit:]]+/) {
					split($2, distra, "/")
					meta["track"] = distra[1]
					meta["disc"] = distra[2]
				} else {
					meta["track"] = $2
				}
				next
			}
			$1 ~ /^[[:space:]]+artist$/ { meta["artist"] = $2; next; }
			$1 ~ /^[[:space:]]+album$/ { meta["album"] = $2; next; }
			$1 ~ /^[[:space:]]+title$/ { meta["title"] = $2; next; }
			$1 ~ /^[[:space:]]+date$/ { meta["date"] = $2; next; }
			$1 ~ /^[[:space:]]+disc$/ { meta["disc"] = $2; next; }
			$1 ~ /^[[:space:]]+Duration$/ {
				meta["duration"] = $2 ":" $3 ":" substr($4, 1, 2); next;
			}
			END {
				# id:artist:album:title:disc:track:date:duration:cover.png
				if (length(meta["artist"]) > 0 && length(meta["title"]) > 0) {
					indexs = "duration:date:track:disc:title:album:artist"
					split(indexs, data, ":")
					for (i = 1; i <= length(data); i++) {
						name = data[i]
						record = meta[name] ";" record
					}
					path = meta["artist"] "-" meta["album"] "-" meta["title"] ".png"
					printf("%s%s\n", record, path)
				} else {
					# essential parts aint here, use file name
					printf("%s\n", meta["filename"])
				}
			}'`
		$as_echo "$incr_song_id;$tags"
		incr_song_id=$(( incr_song_id + 1 ))
	done
}

# add_songs_songs_to_playlist DIR1 DIR2 ....
# ------------------------------------------
# This function simple search for media files in DIRi and add them to the playlist.
# It makes sure to prevent redundency with a huge help from `diff'.
add_songs_to_playlist ()
{
	# The idempotency of `touch' help us prevent 2 `if-else' construct
	touch "$file_name_playlist" "$metadata_playlist"
	# If no arguments were given, then sadp adds the previously added songs to the playlist.
	if test $# -eq 0; then
		if test -s "$metadata_playlist" && test -s "$file_name_playlist" && test -w "$file_name_playlist" && test -w "$metadata_playlist"
		then
			if test `cat "$metadata_playlist" | wc -l` -eq `cat "$file_name_playlist" | wc -l`; then
				: ${media_count=1}
				$as_echo "playlist" | snc | sed -e "$strip_ids" | diff - "$file_name_playlist" | sed -n 's,^> \(.*\),\1,p' |
				while read media_path; do
					test -f "$media_path" && $as_echo "add $media_path" || sed -i "${media_count}d" "$file_name_playlist" "$metadata_playlist"
					media_count=$(( media_count + 1 ))
				done | snc
				# The netcat communication with sad returns a non-zero exit status which may cause
				# a system service to fail after calling `sadp -add'.
				return 0
			fi
		fi
	else
		prev_num_line=`cat "$file_name_playlist" | wc -l`
		incr_song_id=$(( `tail -n1 "$metadata_playlist" | cut -d ';' -f1` + 1 ))
		test $incr_song_id -eq 1 && incr_song_id=0
		# Use `diff' to generate new media files path to be added
		for a_dir in "$@"; do real_path="`readlink -f "$a_dir"`${real_path+;}$real_path"; done
		OLDIFS="$IFS" && IFS=';' && set -- $real_path && IFS="$OLDIFS"
		search_crit="-type f -a ( -iname *.ogg -o -iname *.flac -o -iname *.mp3 -o -iname *.wav )"
		find "$@" $search_crit | diff - "$file_name_playlist" | sed -n 's,^< \(.*\),\1,p' | tee -a "$file_name_playlist" | extract_metadata >> "$metadata_playlist"
		add_lines=`cat "$file_name_playlist" | wc -l`
		if test $add_lines -ne $prev_num_line; then
			tail -$(( add_lines - prev_num_line )) "$file_name_playlist" | while read media_file; do $as_echo "add $media_file"; done | snc
		fi
	fi
}

# remove_song_from_playlist [ID]
# ------------------------------
# remove song with id ID from the playlist.
remove_song_from_playlist ()
{
	if $as_echo	"$1" | grep -q "$digits"; then
		if test $1 -lt `cat "$metadata_playlist" | tail -n1 | cut -d ';' -f1` && test $1 -ge 0
		then
			media_path=`$as_echo "playlist" | snc | sed -n "s/^$1: \(.*\)/\1/p"`
			sed -i "\,^$media_path$,d" "$file_name_playlist"
			sed -i "\,^$1;,d" "$metadata_playlist"
			$as_echo "remove $id" | snc
		fi
	fi
}

# search_songs MENU-COMMAND
# -------------------------
# search_songs open a MENU-COMMAND for you to search and select a song to play.
search_songs ()
{
	: ${menu=$1}
	# Discard arguments and test if the program is installed
	extract_prog_name=${menu%% *}
	command -v "$extract_prog_name" >/dev/null
	case "x$?x" in
		x0x )
		if test -z "`$as_echo "playlist" | snc | sed -e "$strip_ids" | diff - "$file_name_playlist"`"
		then
			if test -f "$metadata_playlist"; then
				metadata='NF == 2 { printf("(%d) [No Name] - %s\n", $1, $2) }; NF > 4 { printf("(%d) %s - %s\n", $1, $2, $4) }'
				song_id=`cat "$metadata_playlist" | awk -F[';'] "$metadata" | eval $menu | sed -e 's/^(\([[:digit:]]\+\)).*$/\1/'`
				if $as_echo "$song_id" | grep -q "$digits"; then
					printf 'play %s\n' "$song_id" | snc
					write_song_id "$song_id"
					#$as_echo "exit code $?"
				else $as_echo "right"; fi
			fi
		fi ;;
		* )
		$as_echo "$me: $extract_prog_name: no such program" ;;
	esac
}

# write_song_id
# -------------
# Creates an empty file whose name is the id of the currently playing song.
# This file is gonna be use for toggling repeat.
write_song_id ()
{
	song_id=$1
	test -z "$song_id" && song_id=`$as_echo "status songid" | snc | cut -d ' ' -f2`
	# Check if SAD has been cleared or stopped.
	case "$song_id" in
		*[0-9] )
		test -f "$cur_song/$song_id" ||
		{ chmod -R 0755 "$cur_song" && rm -Rf "$cur_song"/*
		  touch "$cur_song/$song_id"
		  chmod -R 0500 "$cur_song"
		} ;;
		* ) $as_echo "$me: no song playing" ;;
	esac
}

# toggle_repeat
# -------------
# It's weird but efficient to toggle repeat by creating or deleting the file $rfile, this
# prevents us from opening and reading files with `cat' and `cut'. The presence of the file
# $rfile turns on repeat while it absence turns it off. Waiting for the event 'songfinished'
# so as to know the exact time to repeat the currently playing song.
toggle_repeat ()
{
	trap "test -f '$rfile' && rm -rf '$rfile'" SIGINT SIGHUP SIGKILL
	test -f "$rfile" && (rm -rf "$rfile" || exit 0) || touch "$rfile"
	while test -f "$rfile"; do
		test -n "`write_song_id`" && break
		$as_echo "wait songfinished" | nc -U "$sock" |
		while read event; do
			case "$event" in
				event:*)
				# The permission 0500 garantees that $cur_song only contain a single
				# file whose name is the name of the currently playing song.
				songid=`ls "$cur_song"`
				test -f "$rfile" && $as_echo "play $songid" | snc
				break ;;
			esac
		done
	done
}

# cur_playing_song
# ----------------
# Get information about the currently playing song.
cur_playing_song ()
{
	get_id=`$as_echo "status songid" | snc | cut -d ' ' -f2`
	if $as_echo "$get_id" | grep -qE "$digits"; then
		[ -s "$metadata_playlist" ] && cat "$metadata_playlist" | grep "^$get_id;" | awk -F[';'] '{ printf("%s - %s, Duration: %s\n", $2, $4, $8) }'
	else $as_echo "$me: no song playing"; fi
}

# notification_daemon [xsetroot|herbe|notify-send|...]
# ----------------------------------------------------
# Notify the new playing song through xsetroot/herbe/notify-send  
notification_daemon ()
{
	# If `sapd -notify <progname>' was run as a systemd service, then we gotta specify
	# the display for herbe/xsetroot/etc since systemd doesn't use the X server.
	DISPLAY=:0; export DISPLAY

	case "$1" in
		xsetroot ) _notify='xsetroot -name "$getsong"' ;;
		herbe ) _notify='herbe "SAD" "$getsong"' ;;
		* ) _notify='$1 `$getsong`' ;;
	esac
	while :; do
		$as_echo "wait songfinished" | nc -U /tmp/sad-sock |
		while read event; do
			case "$event" in
				event:* )
				# Sleep 0.2 seconds the time for sad to play the next song.
				sleep 0.2
				getsong=`cur_playing_song`
				eval $_notify
				break ;;
			esac
		done
	done
}

# sad_termui
# ----------
# A simple TUI for sadp
sad_termui () { :; }

# is_main_function "$@"
# ---------------------
main ()
{
	case "x$#x" in
		x0x ) sad_termui ;;
		x1x )
		case "$1" in
			-kill | -clear | -next | -prev | -pause | -random )
			$as_echo "${1#-}" | snc && write_song_id ;;
			-info | -repeat )
			test "X${1#-}" = "Xinfo" && cur_playing_song || toggle_repeat ;;
			-add ) add_songs_to_playlist ;;
			-version | -v ) $as_echo "$version" ;;
			-help | -h ) $as_echo "$usage" ;;
			* ) $as_echo "$help" ;;
		esac ;;
		x2x )
		case "$1" in
			-add )    add_songs_to_playlist "$2" ;;
			-sock )   set_socket "$2" ;;
			-notify ) notification_daemon "$2" ;;
			-search ) search_songs "$2" ;;
			-remove ) remove_song_from_playlist "$2" ;;
			* ) $as_echo "$help" ;;
		esac ;;
		* )
		case "$1" in
			-add ) shift; add_songs_to_playlist "$@" ;;
			* ) $as_echo "$help" ;;
		esac ;;
	esac
}

main "$@"
